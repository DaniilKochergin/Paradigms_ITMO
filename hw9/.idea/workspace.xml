<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="5beaeb7c-f7f9-4183-bc2a-0ce697b3ef61" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/ClojureProjectResolveSettings.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/expression.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsHighLowTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericLsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/Tabulator.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Either.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/ParserTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlAllTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlImageTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlLinkTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlMarkTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/md2html/Md2HtmlUnderlineTest.java" beforeDir="false" />
    </list>
    <ignored path="$PROJECT_DIR$/out/" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/expression.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="17">
              <caret line="58" column="52" lean-forward="true" selection-start-line="58" selection-start-column="52" selection-end-line="58" selection-end-column="52" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>toDiff</find>
      <find>diff</find>
      <find>&amp;</find>
      <find>bonus</find>
      <find>get</find>
      <find>cond</find>
      <find>replace</find>
      <find>drop-</find>
      <find>First argument should be one of</find>
      <find>diffOP</find>
      <find>operations</find>
      <find>declare</find>
      <find>(Constant 0</find>
    </findStrings>
  </component>
  <component name="Git.Settings">
    <option name="UPDATE_TYPE" value="MERGE" />
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/clojure/cljtest/object/ClojureObjectExpressionTest.java" />
        <option value="$PROJECT_DIR$/expression.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds" extendedState="6">
    <option name="x" value="953" />
    <option name="width" value="974" />
    <option name="height" value="1047" />
  </component>
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="Scope" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
              <item name="object" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="examples" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw9" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw9" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
              <item name="expression" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="PackagesPane" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1556539357712" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="undefined stuck path" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
    <property name="nodejs_package_manager_path" value="npm" />
  </component>
  <component name="ReplState" timestamp="1556540038332">{:repl-history {:ide [], :local [{:command &quot;(apply (operations (read-string \&quot;*\&quot;)) (list (Constant 1) (Variable \&quot;x\&quot;)))&quot;, :offset 73, :ns &quot;user&quot;} {:command &quot;(cons (apply (operations (read-string \&quot;*\&quot;)) (list (Constant 1) (Variable \&quot;x\&quot;))) (drop-last 2 (list 1 2)))&quot;, :offset 105, :ns &quot;user&quot;} {:command &quot;(cons 1 (list ))&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(drop-last 3 (list 1 2 3))&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(cons 1 ())&quot;, :offset 11, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 3 \&quot;close\&quot; 3})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&lt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot; ) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5554, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 3 \&quot;close\&quot; 3})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot; ) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5554, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 3 \&quot;close\&quot; 3})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (oper (first op))\n                 ;(takeOperandsWithHighPriority expr\n                 ;                              (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                 ;(drop-last 2 numbers))\n                 ;                             (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot; ) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5556, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (oper (first op))\n                 ;(takeOperandsWithHighPriority expr\n                 ;                              (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                 ;(drop-last 2 numbers))\n                 ;                             (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot; ) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5556, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (oper (first op))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot; ) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5589, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set clearStack\n             (fn [numbers op]\n               (if (empty? op) (first numbers)\n                               (clearStack (cons (apply (operations (first op))\n                                                        (first (split-at 2 numbers))) (second (split-at 2 numbers)))\n                                           (rest op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5553, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (mapv toString numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5197, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5189, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op))\n                                     )))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) 1\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5175, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (list numbers op)\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5134, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (rest op)\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5126, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     expr\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open open\&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5121, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;x * 1\&quot;)\n&quot;, :offset 5141, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;x * 1\&quot;))\n&quot;, :offset 5152, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(parseObjectInfix \&quot;2 * x - 3\&quot;)\n&quot;, :offset 5145, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * x - 3\&quot;))\n&quot;, :offset 5156, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * x - 3\&quot;) {\&quot;x\&quot; 2})\n&quot;, :offset 5164, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def count_args {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 2})\n&quot;, :offset 5216, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def count_args {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last 2 numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5208, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn []) clearStack (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5228, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n\n                    (var-set takeOperands\n                             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                                     (parseExpr expr numbers (rest op))\n                                                     (takeOperands expr\n                                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                                         (drop-last (countArgs (first op)) numbers))\n                                                                   (rest op)))))\n\n                    (var-set takeOperandsWithHighPriority\n                             (fn [expr numbers op opToAdd]\n                               (if (&gt;= (oper (first op)) (oper opToAdd))\n                                 (takeOperandsWithHighPriority expr\n                                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                                     (drop-last 2 numbers))\n                                                               (rest op) opToAdd)\n                                 (parseExpr expr numbers (cons opToAdd op)))))\n\n                    (var-set parseExpr\n                             (fn [expr numbers op]\n                               (if (empty? expr) (first numbers)\n                                                 (cond\n                                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n                    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5608, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                         (drop-last (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5209, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take-last (countArgs (first op)) numbers))\n                                                         (drop-last (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take-last 2 numbers))\n                                                     (drop-last 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5230, :ns &quot;user&quot;} {:command &quot;(take-last 2 (list 1 2 3 4))&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(take 2 (list 1 2 3 4))&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take 2 numbers))\n                                                     (drop 2 numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5210, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;))\n&quot;, :offset 5252, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5259, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5267, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x + 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5267, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x + 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5273, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5273, :ns &quot;user&quot;} {:command &quot;(reverse (list 1 2))&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(reversible? list)&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op))) (reverse '(take (countArgs (first op)) numbers)))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5284, :ns &quot;user&quot;} {:command &quot;(rseq (list 1 2))&quot;, :offset 17, :ns &quot;user&quot;} {:command &quot;(rseq (vector 1 2))&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(rseq (vector (list 1 2)))&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(rseq (apply vector (list 1 2)))&quot;, :offset 32, :ns &quot;user&quot;} {:command &quot;(reverse 1 2)&quot;, :offset 13, :ns &quot;user&quot;} {:command &quot;(rseq 1 2)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(apply vector (list 1 2))&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers)))\n                                                                (drop (countArgs (first op)) numbers))\n                                                         (rest op)))))\n\n             (var-set takeOperandsWithHighPriority\n                      (fn [expr numbers op opToAdd]\n                        (if (&gt;= (oper (first op)) (oper opToAdd))\n                          (takeOperandsWithHighPriority expr\n                                                        (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                              (drop (countArgs (first op)) numbers))\n                                                        (rest op) opToAdd)\n                          (parseExpr expr numbers (cons opToAdd op)))))\n\n             (var-set parseExpr\n                      (fn [expr numbers op]\n                        (if (empty? expr) (first numbers)\n                                          (cond\n                                            (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                            (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                            (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                            (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                            :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n             (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n             )\n    )\n\n  (defn parseObjectInfix [str] (parseInfix [str]))\n\n  (evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5548, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x - 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5359, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5359, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.a this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; -1})&quot;, :offset 5360, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; -1})&quot;, :offset 5362, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n(def oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0})\n(def countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1})\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; -1})&quot;, :offset 5510, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; -1})&quot;, :offset 5391, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;) {\&quot;x\&quot; -1})&quot;, :offset 5391, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;))&quot;, :offset 5382, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (str (.val this)))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;))&quot;, :offset 5372, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;2 * ( x / 3 )\&quot;))&quot;, :offset 5391, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(toString (parseObjectInfix \&quot;negate 1\&quot;))&quot;, :offset 5386, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (replace (replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5394, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (clojure.string/replace (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) #\&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5422, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join split replace)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (clojure.string/replace (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) #\&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5430, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (split (str \&quot;open \&quot; (clojure.string/replace (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) #\&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5403, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split (str \&quot;open \&quot; (clojure.string/replace (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) #\&quot;)\&quot; \&quot; close \&quot;) \&quot; close\&quot;) #\&quot;\\s+\&quot;) (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5431, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n(defn ExprToToken [expr]\n  (split expr #\&quot;\\s+\&quot;))\n\n(definterface parseInterface\n  (parseExpr []))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5547, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (parseObjectInfix \&quot;negate 1\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5450, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;negate 1\&quot;))&quot;, :offset 5442, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;negate (1 * x + 23 - 2/4\&quot;))&quot;, :offset 5458, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;negate (1 * x + 23 - 2/4)\&quot;))&quot;, :offset 5459, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;(2 + 5 * x)\&quot;))&quot;, :offset 5445, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;3\&quot;))&quot;, :offset 5435, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;3 + 2\&quot;))&quot;, :offset 5439, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;(3 + 2)\&quot;)) &quot;, :offset 5442, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;( 3 + 2 )\&quot;))&quot;, :offset 5443, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (parseObjectInfix \&quot;negate ( 1 * x + 23 - 2 / 4 )\&quot;))&quot;, :offset 5463, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(toString (diff (parseObjectInfix \&quot;negate ( 1 * x + 23 - 2 / 4 )\&quot;) \&quot;x\&quot;))&quot;, :offset 5474, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot;open\&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (diff (parseObjectInfix \&quot;negate ( 1 * x + 23 - 2 / 4 )\&quot;) \&quot;x\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5482, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (diff (parseObjectInfix \&quot;negate (1 * x + 23 - 2/4)\&quot;) \&quot;x\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5480, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (diff (parseObjectInfix \&quot;negate (1 * x+23 - 2/4)\&quot;) \&quot;x\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5478, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n(evaluate (diff (parseObjectInfix \&quot;negate (1 * x + 23 - 2 / 4)\&quot;) \&quot;x\&quot;) {\&quot;x\&quot; 1})&quot;, :offset 5482, :ns &quot;user&quot;} {:command &quot;(diff (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;)&quot;, :offset 60, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) x))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;)&quot;, :offset 6407, :ns &quot;user&quot;} {:command &quot;(evaluate (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) {\&quot;x\&quot; 1 \&quot;y\&quot; 2})&quot;, :offset 74, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(evaluate (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) {\&quot;x\&quot; 1 \&quot;y\&quot; 2})&quot;, :offset 6430, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;)&quot;, :offset 6416, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;)&quot;, :offset 6433, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;)) \&quot;x\&quot;)&quot;, :offset 6424, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(toString (diff (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;)) \&quot;x\&quot;))&quot;, :offset 6435, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Subtract (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;y\&quot;)&quot;, :offset 6433, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Constant 2) (Square x) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;y\&quot;)&quot;, :offset 6428, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Multiply (Constant 2) (Square x)) (Constant x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 1 \&quot;open\&quot; 0 \&quot;close\&quot; 0}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;y\&quot;)&quot;, :offset 6439, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Multiply (Constant 2) (Square x)) x_der))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;y\&quot;)&quot;, :offset 6448, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Multiply (Constant 2) x) x_der))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;y\&quot;)&quot;, :offset 6439, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Multiply (Constant 2) x) x_der))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(eval (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) {\&quot;y\&quot; 1 \&quot;x\&quot; 2})&quot;, :offset 6449, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x))\n                                                              (Multiply (Multiply (Constant 2) x) x_der))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(evaluate (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) {\&quot;y\&quot; 1 \&quot;x\&quot; 2})&quot;, :offset 6453, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x)\n                                                                                  (Multiply (Multiply (Constant 2) x) x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(evaluate (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) {\&quot;y\&quot; 1 \&quot;x\&quot; 2})&quot;, :offset 6473, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x)\n                                                                                  (Multiply (Multiply (Constant 2) x) x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;)&quot;, :offset 6459, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x)\n                                                                                  (Multiply (Multiply (Constant 2) x) x_der)))))\n\n;(defn Abs [operand]\n;  (OperationFactory. (list operand) 'abs (fn[x](max x (- x))) (fn[x x_der] (list (Abs x)\n;                                                                                 (.diffJava (Abs x)))))\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt x)\n                                                                                                 (Divide\n                                                                                                   (Constant 1)\n                                                                                                   (Multiply (Constant 2) (Constant 1)))))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(toString (diff (Square (Add (Variable \&quot;x\&quot;) (Variable \&quot;y\&quot;))) \&quot;x\&quot;))&quot;, :offset 6470, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x)\n                                                                                  (Multiply (Multiply (Constant 2) x) x_der)))))\n\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt (Sqrt (Square x)))\n                                                                                                 (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                                   (Multiply (Constant 2) x)) x_der)))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(toString (parseObjectInfix \&quot;sqrt 4\&quot;))&quot;, :offset 6197, :ns &quot;user&quot;} {:command &quot;(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [this _] (ConstantObj. 0.0)))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (diffJava [this name] (ConstantObj. (if (= name (.val this)) 1.0 0.0))))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this)))))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n(defn Add [&amp; operands]\n  (OperationFactory. operands '+ + (diffOp (fn [[x x_der] [y y_der]]\n                                             (list (Add x y) (Add x_der y_der))))))\n\n(defn Subtract [&amp; operands]\n  (OperationFactory. operands '- - (fn [[x x_der] [y y_der]]\n                                     (list (Subtract x y) (Subtract x_der y_der)))))\n\n(defn Multiply [&amp; operands]\n  (OperationFactory. operands '* * (fn [[x x_der] [y y_der]]\n                                     (list (Multiply x y)\n                                           (Add\n                                             (Multiply y x_der) (Multiply x y_der))))))\n\n(defn smart-div\n  [&amp; values]\n  (reduce (fn [x y] (/ (double x) (double y))) values))\n\n(defn Constant [a] (ConstantObj. a))\n\n(defn Variable [a] (VariableObj. a))\n\n(defn Divide [&amp; operands]\n  (OperationFactory. operands '/ smart-div (fn [[x x_der] [y y_der]]\n                                             (list (Divide x y)\n                                                   (Divide\n                                                     (Subtract\n                                                       (Multiply y x_der) (Multiply x y_der))\n                                                     (Multiply y y))))))\n\n(defn Negate [operand]\n  (OperationFactory. (list operand) 'negate - (fn [[x x_der]] (list (Negate x)\n                                                                    (Negate x_der)))))\n\n\n(defn Square [operand]\n  (OperationFactory. (list operand) 'square (fn[x] (* x x)) (fn [[x x_der]] (list (Square x)\n                                                                                  (Multiply (Multiply (Constant 2) x) x_der)))))\n\n\n(defn Sqrt [operand]\n  (OperationFactory. (list operand) 'sqrt (fn[x] (Math/sqrt (max x (- x)))) (fn[[x x_der]] (list (Sqrt (Sqrt (Square x)))\n                                                                                                 (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                                   (Multiply (Constant 2) x)) x_der)))))\n\n\n(defn evaluate [this vars] (.evalJava this vars))\n\n(defn toString [this] (.toStringJava this))\n\n(defn diff [this var] (.diffJava this var))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    oper {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;open\&quot; 0 \&quot;close\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;open\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (oper (first op)) (oper opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;open\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;close\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (read-string (first expr))) (parseExpr (rest expr) (cons (Constant (read-string (first expr))) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (clojure.string/split\n                 (str \&quot;open \&quot;\n                      (clojure.string/replace\n                        (clojure.string/replace (apply str expr) \&quot;(\&quot; \&quot; open \&quot;) \&quot;)\&quot; \&quot; close \&quot;)\n                      \&quot; close\&quot;)\n                 #\&quot;\\s+\&quot;)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [str] (parseInfix [str]))\n\n\n(evaluate (parseObjectInfix \&quot;sqrt 4\&quot;) \&quot;x\&quot;)&quot;, :offset 6201, :ns &quot;user&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Application.ClojureObjectSquareSqrtTest">
    <configuration name="ClojureObjectSquareSqrtTest" type="Application" factoryName="Application" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="cljtest.object.ClojureObjectSquareSqrtTest" />
      <module name="hw9" />
      <option name="PROGRAM_PARAMETERS" value="hard" />
      <option name="VM_PARAMETERS" value="-ea" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" nameIsGenerated="true">
      <module name="hw9" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Application.ClojureObjectSquareSqrtTest" />
      <item itemvalue="Clojure REPL.Unnamed" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="5beaeb7c-f7f9-4183-bc2a-0ce697b3ef61" name="Default Changelist" comment="" />
      <created>1556380414454</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1556380414454</updated>
      <workItem from="1556380418541" duration="9789000" />
      <workItem from="1556391948812" duration="168000" />
      <workItem from="1556428149143" duration="35335000" />
      <workItem from="1556524174834" duration="2061000" />
      <workItem from="1556526560984" duration="751000" />
      <workItem from="1556533628020" duration="4850000" />
    </task>
    <servers />
  </component>
  <component name="TimeTrackingManager">
    <option name="totallyTimeSpent" value="52954000" />
  </component>
  <component name="ToolWindowManager">
    <frame x="-8" y="-8" width="1936" height="1056" extended-state="6" />
    <editor active="true" />
    <layout>
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.07835821" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info id="Image Layers" order="2" />
      <window_info id="Designer" order="3" />
      <window_info id="UI Designer" order="4" />
      <window_info id="Capture Tool" order="5" />
      <window_info id="Favorites" order="6" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info active="true" anchor="bottom" id="Run" order="2" sideWeight="0.49573562" visible="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.3997833" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.32936078" />
      <window_info anchor="bottom" id="Docker" order="7" show_stripe_button="false" />
      <window_info anchor="bottom" id="Version Control" order="8" weight="0.32936078" />
      <window_info anchor="bottom" id="Database Changes" order="9" />
      <window_info anchor="bottom" id="Terminal" order="10" weight="0.32936078" />
      <window_info anchor="bottom" id="Event Log" order="11" sideWeight="0.5042644" side_tool="true" visible="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Messages" order="12" weight="0.32936078" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="1" weight="0.25" />
      <window_info anchor="right" id="Palette" order="2" />
      <window_info anchor="right" id="Theme Preview" order="3" />
      <window_info anchor="right" id="Ant Build" order="4" sideWeight="0.49919224" weight="0.25" />
      <window_info anchor="right" id="Maven" order="5" weight="0.32995737" />
      <window_info anchor="right" id="Capture Analysis" order="6" />
      <window_info anchor="right" id="Palette&#9;" order="7" />
      <window_info anchor="right" id="Database" order="8" weight="0.32995737" />
      <window_info anchor="right" id="Leiningen" order="9" weight="0.32995737" />
      <window_info anchor="right" id="REPL" order="10" sideWeight="0.50080776" side_tool="true" weight="0.3336887" />
      <window_info anchor="right" id="Coverage" order="11" side_tool="true" weight="0.32995737" />
    </layout>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/functional/ClojureFunctionalExpressionTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="425">
          <caret line="31" column="1" selection-start-line="31" selection-start-column="1" selection-end-line="31" selection-end-column="1" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/3_1_js-objects.clj">
      <provider selected="true" editor-type-id="text-editor" />
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/3_2_java-objects.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1258">
          <caret line="74" column="30" selection-start-line="74" selection-start-column="30" selection-end-line="74" selection-end-column="30" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/ClojureScript.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="21" column="41" selection-start-line="21" selection-start-column="41" selection-end-line="21" selection-end-column="41" />
          <folding>
            <element signature="e#336#337#0" expanded="true" />
            <element signature="e#407#408#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/object/ClojureObjectExpressionTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="401">
          <caret line="81" column="92" selection-start-line="81" selection-start-column="92" selection-end-line="81" selection-end-column="92" />
          <folding>
            <element signature="imports" expanded="true" />
            <element signature="e#819#820#0" expanded="true" />
            <element signature="e#875#876#0" expanded="true" />
            <element signature="e#1125#1126#0" expanded="true" />
            <element signature="e#1186#1187#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/ClojureEngine.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="262">
          <caret line="33" column="5" lean-forward="true" selection-start-line="33" selection-start-column="5" selection-end-line="33" selection-end-column="5" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/expression.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="58" column="52" lean-forward="true" selection-start-line="58" selection-start-column="52" selection-end-line="58" selection-end-column="52" />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>11</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>