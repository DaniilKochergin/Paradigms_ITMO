<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="3197dfe5-7a24-452b-8888-fa7ef8063d5f" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/ClojureProjectResolveSettings.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/clojure/examples/4_1_base.clj" beforeDir="false" afterPath="$PROJECT_DIR$/clojure/examples/4_1_base.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/clojure/examples/4_3_json.clj" beforeDir="false" afterPath="$PROJECT_DIR$/clojure/examples/4_3_json.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsHighLowTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericLsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/Tabulator.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Either.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/ParserTest.java" beforeDir="false" />
    </list>
    <ignored path="$PROJECT_DIR$/out/" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/expression.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="408">
              <caret line="24" column="26" lean-forward="true" selection-start-line="24" selection-start-column="26" selection-end-line="24" selection-end-column="26" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/obj.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="1785">
              <caret line="105" selection-start-line="105" selection-end-line="105" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/combinators.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="629">
              <caret line="37" column="5" selection-start-line="37" selection-start-column="5" selection-end-line="37" selection-end-column="5" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>Divide</find>
      <find>opera</find>
      <find>tos</find>
      <find>.to</find>
      <find>(any</find>
      <find>smart-div</find>
      <find>any-</find>
      <find>symbol</find>
      <find>-valid?</find>
      <find>str</find>
      <find>expression</find>
      <find>negate</find>
      <find>force</find>
      <find>*number</find>
      <find>char-array</find>
      <find>t</find>
      <find>conj-list</find>
      <find>map</find>
      <find>+map</find>
      <find>_map</find>
      <find>null</find>
      <find>*</find>
      <find>+strin</find>
      <find>+stri</find>
      <find>+string</find>
      <find>+try</find>
      <find>*operator</find>
      <find>_try</find>
      <find>+str</find>
      <find>any-args</find>
    </findStrings>
  </component>
  <component name="Git.Settings">
    <option name="UPDATE_TYPE" value="MERGE" />
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/clojure/examples/4_2_combinators.clj" />
        <option value="$PROJECT_DIR$/clojure/expression.clj" />
        <option value="$PROJECT_DIR$/clojure/examples/4_3_json.clj" />
        <option value="$PROJECT_DIR$/clojure/examples/4_1_base.clj" />
        <option value="$PROJECT_DIR$/combinators.clj" />
        <option value="$PROJECT_DIR$/obj.clj" />
        <option value="$PROJECT_DIR$/expression.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds" extendedState="6">
    <option name="x" value="-7" />
    <option name="width" value="974" />
    <option name="height" value="1047" />
  </component>
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="PackagesPane" />
      <pane id="Scope" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="hw10" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw10" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw10" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw10" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw10" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw10" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw10" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw10" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
              <item name="parsing" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw10" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw10" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="examples" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1557734258926" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/../hw7" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="undefined stuck path" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
    <property name="nodejs_package_manager_path" value="npm" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="C:\ITMO_Paradigms\secondsem\hw10" />
      <recent name="C:\ITMO_Paradigms\secondsem\hw10\clojure" />
    </key>
  </component>
  <component name="ReplState" timestamp="1557673650697">{:repl-history {:ide [], :local [{:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (type (first expr)))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 8801, :ns &quot;user&quot;} {:command &quot;(cons 1 (1 2 3))&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(conj 1 (1 2 3))&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(conj 1 (list 1 2 3))&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(cons 1 (list 1 2 3))&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(type (cons 1 (list 1 2 3)))&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(type (first (cons 1 (list 1 2 3))))&quot;, :offset 36, :ns &quot;user&quot;} {:command &quot;(type (first (cons (list 1) (list 1 2 3))))&quot;, :offset 43, :ns &quot;user&quot;} {:command &quot;(= clojure.lang.Cons (type (cons 1 (list 1 2 3))))&quot;, :offset 50, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (or (list? (first expr)) (= clojure.lang.Cons (type (first expr)))) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9554, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (or (list? (first expr)) (= Cons (type (first expr)))) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9541, :ns &quot;user&quot;} {:command &quot;(seq? (cons 1 (list 1 2 3)))&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (first expr)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9446, :ns &quot;user&quot;} {:command &quot;(seq? [1 2 3])&quot;, :offset 14, :ns &quot;user&quot;} {:command &quot;(seq? (list 1 2 3))&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (parseExpr (first expr) () ())\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9464, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               op)))\n\n  (var-set parseExpr\n           (fn [expr numbers op]\n             (if (empty? expr) (first numbers)\n                               (cond\n                                 (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                 (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                 (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                 (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                 (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                 :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n  (parseExpr (expression expr)\n             (list) (list))\n  )\n)\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9008, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               op))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9035, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9294, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression (+parser (+seqn 0 *ws (*value) *ws)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9506, :ns &quot;user&quot;} {:command &quot;(cons () (list 1 2 3))&quot;, :offset 22, :ns &quot;user&quot;} {:command &quot;(apply cons () (list (1 2) (3 4)))&quot;, :offset 34, :ns &quot;user&quot;} {:command &quot;(map (partial cons ()) (list (1 2) (3 4)))&quot;, :offset 42, :ns &quot;user&quot;} {:command &quot;(map (partial cons ()) [(1 2) (3 4)])&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(cons () (1 2))&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(cons () (list 1 2))&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(reduce cons ((+parser (+seqn 0 *ws (*value) *ws)) %))\n\n\n  (defn parseInfix [expr]\n    (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                      priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                      countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n      (var-set takeOperands\n               (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                       (parseExpr expr numbers (rest op))\n                                       (takeOperands expr\n                                                     (cons (apply (operations (read-string (first op)))\n                                                                  (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                           (drop (countArgs (first op)) numbers))\n                                                     (rest op)))))\n\n      (var-set takeOperandsWithHighPriority\n               (fn [expr numbers op opToAdd]\n                 (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                   (takeOperandsWithHighPriority expr\n                                                 (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                       (drop (countArgs (first op)) numbers))\n                                                 (rest op) opToAdd)\n                   (parseExpr expr numbers (cons opToAdd op)))))\n\n      (var-set parseExpr\n               (fn [expr numbers op]\n                 (if (empty? expr) (first numbers)\n                                   (cond\n                                     (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                     (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                     (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                     (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                     (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                     :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n      (parseExpr (expression expr)\n                 (list) (list))\n      )\n    )\n\n  (defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9594, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(reduce cons ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (seq? (first expr)) (parseExpr (rest expr) (cons (parseExpr (first expr) () ()) numbers) op)\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9525, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(reduce cons ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; expr \&quot;)\&quot;)))&quot;, :offset 9397, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10))\&quot;)&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(parseObjectInfix \&quot;(10)\&quot;)&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(parseObjectInfix \&quot;10\&quot;)&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(parseObjectInfix \&quot;(10+2)\&quot;)&quot;, :offset 27, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10+2)-5)\&quot;)&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (apply list obj)\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (cons (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(reduce cons ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9405, :ns &quot;user&quot;} {:command &quot;(expression \&quot;(10-2)\&quot;)&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(expression \&quot;(10-x)\&quot;)&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(parseObjectInfix \&quot;(10-x)\&quot;)&quot;, :offset 27, :ns &quot;user&quot;} {:command &quot;(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (reduce cons [(make-vector (first obj)) (make-vector (rest obj))])\n      (cons (first obj) (make-vector (rest obj))))))\n&quot;, :offset 203, :ns &quot;user&quot;} {:command &quot;(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (reduce cons () [(make-vector (first obj)) (make-vector (rest obj))])\n      (cons (first obj) (make-vector (rest obj))))))&quot;, :offset 205, :ns &quot;user&quot;} {:command &quot;(make-vector [1 [2 3]])&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(make-vector (1 [2 3]))&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (reduce cons [(make-vector (first obj)) (make-vector (rest obj))])\n      (cons (first obj) (make-vector (rest obj))))))&quot;, :offset 202, :ns &quot;user&quot;} {:command &quot;(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (into (list (first obj)) (make-vector (rest obj))))))&quot;, :offset 200, :ns &quot;user&quot;} {:command &quot;(make-vector (list 1 (list 2 3)))&quot;, :offset 33, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (into (list (first obj)) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9393, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10-2)+3)\&quot;)&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(make-vector (list (list (1 2) 3)))&quot;, :offset 35, :ns &quot;user&quot;} {:command &quot;(make-vector (list (list 1 2) 3))&quot;, :offset 33, :ns &quot;user&quot;} {:command &quot;(conj (list 1 2) (list 3 4))&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (list? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (conj (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9386, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (conj (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9385, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqn 1\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9385, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10+2)-4)\&quot;)&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+char \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9388, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+str \&quot;(\&quot;)\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+str \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9386, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+opt (+star (+seqn 0 *ws p))) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9410, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10+2))\&quot;)&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+seqn 0 *ws p)) *ws\n  (+map str (+char \&quot;)\&quot;)))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9367, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value [] (delay (+or\n                         (+seqf list *operation *negnumber)\n                         (+seqf list *operation *number)\n                         (+seqf list *operation *variable)\n                         *number\n                         *variable\n                         (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9403, :ns &quot;user&quot;} {:command &quot;(expression \&quot;(10 + 2)\&quot;)&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(expression \&quot;((10 + 2)-2)\&quot;)&quot;, :offset 27, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(def *value (+plus (+seqf list (+opt (+map str (+char \&quot;(\&quot;)))\n                          (+or\n                            (+seqf list *operation *negnumber)\n                            (+seqf list *operation *number)\n                            (+seqf list *operation *variable)\n                            *number\n                            *variable)\n                          (+opt (+map str (+char \&quot;)\&quot;))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws *value *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9488, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(def *value (+star (+seqf list (+opt (+map str (+char \&quot;(\&quot;)))\n                          (+or\n                            (+seqf list *operation *negnumber)\n                            (+seqf list *operation *number)\n                            (+seqf list *operation *variable)\n                            *number\n                            *variable)\n                          (+opt (+map str (+char \&quot;)\&quot;))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws *value *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9488, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (*in-brackets (*value))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9360, :ns &quot;user&quot;} {:command &quot;(expression \&quot;10\&quot;)&quot;, :offset 17, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9410, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9414, :ns &quot;user&quot;} {:command &quot;(expression \&quot;(10+2)\&quot;)&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (force (+star (+seqn 0 *ws p *ws))) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (force (*value))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (force (+seqn 0 *ws p *ws))) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws (force p) *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (delay (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9372, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (delay (*in-brackets (force (*value))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9380, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          (force *number)\n                          *variable\n                          (*in-brackets (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (delay (*value))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9422, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws (force p) *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (delay (+or\n                          (+seqf list *operation *negnumber)\n                          (+seqf list *operation *number)\n                          (+seqf list *operation *variable)\n                          *number\n                          *variable\n                          (*in-brackets (delay (*value))))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9430, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (*in-brackets (delay (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9372, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+star (+seqn 0 *ws (force p) *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (*in-brackets (delay (*value)))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9380, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+plus (+seqn 0 *ws p *ws)) *ws\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (*in-brackets (*value))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9364, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n(defn _show [result]\n  (if (-valid? result) (str \&quot;-&gt; \&quot; (pr-str (-value result)) \&quot; | \&quot; (pr-str (apply str (-tail result))))\n                       \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p]\n  (fn [[c &amp; cs]]\n    (if (and c (p c)) (-return c cs))))\n(defn _map [f]\n  (fn [result]\n    (if (-valid? result)\n      (-return (f (-value result)) (-tail result)))))\n\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n\n(defn _either [a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar) ar ((force b) str)))))\n\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(mapv (_parser (_combine str (_char #{\\a \\b}) (_char #{\\x}))) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;])\n\n(defn +char [chars] (_char (set chars)))\n\n(defn +char-not [chars] (_char (comp not (set chars))))\n\n(defn +map [f parser] (comp (_map f) parser))\n\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly 'ignore)))\n\n(defn iconj [coll value]\n  (if (= value 'ignore) coll (conj coll value)))\n(defn +seq [&amp; ps]\n  (reduce (partial _combine iconj) (_empty []) ps))\n\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn +or [p &amp; ps]\n  (reduce (partial _either) p ps))\n\n(defn +opt [p]\n  (+or p (_empty nil)))\n\n(defn +star [p]\n  (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n\n(defn +plus [p] (+seqf cons p (+star p)))\n\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (seq (char-array s)))))\n(def *all-chars (mapv char (range 0 128)))\n\n(def *space (+char (apply str (filter #(Character/isWhitespace %) *all-chars))))\n\n(def *ws (+ignore (+star *space)))\n\n(use '[clojure.string :only (join)])\n(definterface OperationInterface\n  (evalJava [args]) (toStringJava []) (diffJava [name]) (toStringInfixJava []))\n\n(deftype ConstantObj\n  [val]\n  OperationInterface\n  (evalJava [this _] (.val this))\n  (toStringJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (toStringInfixJava [this] (format \&quot;%.1f\&quot; (double (.val this))))\n  (diffJava [_ _] (ConstantObj. 0.0)))\n\n\n(def CONST_ZERO (ConstantObj. 0))\n(def CONST_ONE (ConstantObj. 1))\n(def CONST_TWO (ConstantObj. 2))\n\n(deftype VariableObj\n  [val]\n  OperationInterface\n  (evalJava [this args] (args (.val this)))\n  (toStringJava [this] (.val this))\n  (toStringInfixJava [this] (.val this))\n  (diffJava [this name] (if (= name (.val this)) CONST_ONE CONST_ZERO)))\n\n\n(def Constant #(ConstantObj. %))\n(def Variable #(VariableObj. %))\n\n(deftype OperationFactory\n  [operands symbol f der]\n  OperationInterface\n  (evalJava [this args] (apply f (map #(.evalJava % args) (.operands this))))\n  (toStringJava [this] (str \&quot;(\&quot; (join \&quot; \&quot; (cons symbol (map #(.toStringJava %) (.operands this)))) \&quot;)\&quot;))\n  (diffJava [this name] (second (apply der (map list (.operands this) (map #(.diffJava % name) (.operands this))))))\n  (toStringInfixJava [this] (if (&gt; (count (.operands this)) 1) (str \&quot;(\&quot; (join symbol (map #(.toStringInfixJava %) (.operands this))) \&quot;)\&quot;)\n                                                               (str symbol \&quot;(\&quot; (.toStringInfixJava (first operands)) \&quot;)\&quot;))))\n\n(defn diffOp [f] #(reduce f %&amp;))\n\n\n(defn operation [symbol f der]\n  #(OperationFactory. %&amp; symbol f (diffOp der)))\n(def Add (operation '+ + (fn [[x x_der] [y y_der]]\n                           [(Add x y) (Add x_der y_der)])))\n\n(def Subtract (operation '- - (fn [[x x_der] [y y_der]]\n                                [(Subtract x y) (Subtract x_der y_der)])))\n\n(def Multiply (operation '* * (fn [[x x_der] [y y_der]]\n                                [(Multiply x y)\n                                 (Add\n                                   (Multiply y x_der) (Multiply x y_der))])))\n\n(def smart-div #(reduce (fn [x y] (/ (double x) (double y))) %&amp;))\n\n(def Divide (operation '/ smart-div (fn [[x x_der] [y y_der]]\n                                      [(Divide x y)\n                                       (Divide\n                                         (Subtract\n                                           (Multiply y x_der) (Multiply x y_der))\n                                         (Multiply y y))])))\n\n\n\n(defn unaryOperation [symbol f der]\n  #(OperationFactory. [%] symbol f der))\n\n\n(def Negate (unaryOperation 'negate - (fn [[x x_der]] [(Negate x)\n                                                       (Negate x_der)])))\n\n(def Square (unaryOperation 'square (fn [x] (* x x)) (fn [[x x_der]] [(Square x)\n                                                                      (Multiply (Multiply CONST_TWO x) x_der)])))\n\n(def Sqrt (unaryOperation 'sqrt (fn [x] (Math/sqrt (max x (- x)))) (fn [[x x_der]] [(Sqrt (Sqrt (Square x)))\n                                                                                    (Multiply (Divide (Sqrt (Sqrt (Square x)))\n                                                                                                      (Multiply CONST_TWO x)) x_der)])))\n\n\n(def evaluate #(.evalJava %1 %2))\n\n(def toString #(.toStringJava %))\n\n(def toStringInfix #(.toStringInfixJava %))\n\n(def diff #(.diffJava %1 %2))\n\n(def operations {'+ Add '- Subtract '* Multiply '/ Divide 'negate Negate 'sqrt Sqrt 'square Square})\n\n\n(defn parse [expr]\n  (cond (list? expr) (apply (operations (first expr))\n                            (map parse (rest expr)))\n        (number? expr) (Constant expr)\n        :else (Variable (str expr))))\n\n(defn parseObject [expr]\n  (parse (read-string expr)))\n\n\n(def operators [\&quot;*\&quot; \&quot;/\&quot; \&quot;+\&quot; \&quot;-\&quot; \&quot;negate\&quot;])\n(def *digit (+char \&quot;0123456789.\&quot;))\n(defn *in-brackets [p] (+seqf list\n                              (+map str (+char \&quot;(\&quot;))\n                              (+seqn 0 *ws p *ws)\n                              (+map str (+char \&quot;)\&quot;))))\n(def *number (+map read-string (+str (+plus *digit))))\n(def *negnumber (+map read-string (+str (+seqf cons (+char \&quot;-\&quot;) (+plus *digit)))))\n(def *operation (+map str (apply +or (map +string operators))))\n(def *variable (+map str (+char \&quot;xyz\&quot;)))\n(defn *value []  (+or\n                   (+seqf list *operation *negnumber)\n                   (+seqf list *operation *number)\n                   (+seqf list *operation *variable)\n                   *number\n                   *variable\n                   (*in-brackets (*value))))\n\n(defn make-vector[obj]\n  (if (empty? obj)\n    ()\n    (if (seq? (first obj))\n      (into (make-vector (first obj)) (make-vector (rest obj)))\n      (cons (first obj) (make-vector (rest obj))))))\n\n(def expression #(make-vector ((+parser (+seqn 0 *ws (*value) *ws)) %)))\n\n\n(defn parseInfix [expr]\n  (with-local-vars [takeOperands (fn []) takeOperandsWithHighPriority (fn []) parseExpr (fn [])\n                    priorityOperands {\&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 1 \&quot;+\&quot; 1 \&quot;negate\&quot; 3 \&quot;(\&quot; 0 \&quot;)\&quot; 0 \&quot;square\&quot; 3 \&quot;sqrt\&quot; 3}\n                    countArgs {\&quot;+\&quot; 2 \&quot;*\&quot; 2 \&quot;/\&quot; 2 \&quot;-\&quot; 2 \&quot;negate\&quot; 1 \&quot;sqrt\&quot; 1 \&quot;square\&quot; 1}]\n\n    (var-set takeOperands\n             (fn [expr numbers op] (if (= \&quot;(\&quot; (first op))\n                                     (parseExpr expr numbers (rest op))\n                                     (takeOperands expr\n                                                   (cons (apply (operations (read-string (first op)))\n                                                                (rseq (apply vector (take (countArgs (first op)) numbers))))\n                                                         (drop (countArgs (first op)) numbers))\n                                                   (rest op)))))\n\n    (var-set takeOperandsWithHighPriority\n             (fn [expr numbers op opToAdd]\n               (if (&gt;= (priorityOperands (first op)) (priorityOperands opToAdd))\n                 (takeOperandsWithHighPriority expr\n                                               (cons (apply (operations (read-string (first op))) (take (countArgs (first op)) numbers))\n                                                     (drop (countArgs (first op)) numbers))\n                                               (rest op) opToAdd)\n                 (parseExpr expr numbers (cons opToAdd op)))))\n\n    (var-set parseExpr\n             (fn [expr numbers op]\n               (if (empty? expr) (first numbers)\n                                 (cond\n                                   (= \&quot;(\&quot; (first expr)) (parseExpr (rest expr) numbers (cons (first expr) op))\n                                   (= \&quot;)\&quot; (first expr)) (takeOperands (rest expr) numbers op)\n                                   (number? (first expr)) (parseExpr (rest expr) (cons (Constant (first expr)) numbers) op)\n                                   (nil? (find operations (read-string (first expr)))) (parseExpr (rest expr) (cons (Variable (first expr)) numbers) op)\n                                   :else (takeOperandsWithHighPriority (rest expr) numbers op (first expr))))))\n    (parseExpr (expression expr)\n               (list) (list))\n    )\n  )\n\n(defn parseObjectInfix [expr] (parseInfix (str \&quot;(\&quot; \&quot;(\&quot; expr \&quot;)\&quot; \&quot;)\&quot;)))&quot;, :offset 9352, :ns &quot;user&quot;} {:command &quot;(expression \&quot;(10)\&quot;)&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;((+seq (+ignore (+opt (+char \&quot;a\&quot;) (+char nil)) (+char \&quot;b\&quot;)) \&quot;b\&quot;)&quot;, :offset 64, :ns &quot;user&quot;} {:command &quot;((+seq (+ignore (+opt (+char \&quot;a\&quot;) (+char nil)) (+char \&quot;b\&quot;)) \&quot;b\&quot;))&quot;, :offset 65, :ns &quot;user&quot;} {:command &quot;((+seq (+opt (+char \&quot;a\&quot;) (+char \&quot;b\&quot;)) (+ignore (+char nil))) \&quot;b\&quot;)&quot;, :offset 65, :ns &quot;user&quot;} {:command &quot;((+seq (+opt (+char \&quot;a\&quot;)) (+char \&quot;b\&quot;) (+ignore (+char nil))) \&quot;b\&quot;)&quot;, :offset 65, :ns &quot;user&quot;} {:command &quot;((+seq (+opt (+char \&quot;a\&quot;)) (+char \&quot;b\&quot;)) \&quot;b\&quot;)&quot;, :offset 43, :ns &quot;user&quot;} {:command &quot;(into () (1 2))&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(into list (1 2))&quot;, :offset 17, :ns &quot;user&quot;} {:command &quot;(apply (partial identity) (list 1 2))&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(tabulate (_combine str (_char #{\\a \\b}) (_char #{\\x})) [\&quot;ax\&quot; \&quot;ax~\&quot; \&quot;bx\&quot; \&quot;bx~\&quot; \&quot;\&quot; \&quot;a\&quot; \&quot;x\&quot; \&quot;xa\&quot;]))&quot;, :offset 97, :ns &quot;user&quot;} {:command &quot;(defn -return [value tail] {:value value :tail tail})\n(def -valid? boolean)\n(def -value :value)\n(def -tail :tail)\n\n(defn _show [result]\n  (if (-valid? result)\n    (str \&quot;-&gt; \&quot;\n         (pr-str (-value result)) \&quot; | \&quot;\n         (pr-str (apply str (-tail result))))\n    \&quot;!\&quot;))\n(defn tabulate [parser inputs]\n  (run! (fn [input] (printf \&quot;    %-10s %s\\n\&quot; input (_show (parser input)))) inputs))\n\n(defn _empty [value] (partial -return value))\n(defn _char [p] (fn [[c &amp; cs]] (if (and c (p c)) (-return c cs))))\n(defn _map [f] (fn [result] (if (-valid? result)\n                              (-return (f (-value result)) (-tail result)))))\n(defn _combine [f a b]\n  (fn [str]\n    (let [ar ((force a) str)]\n      (if (-valid? ar)\n        ((_map (partial f (-value ar)))\n          ((force b) (-tail ar)))))))\n(defn _either [a b]\n  (fn [str] (let [ar ((force a) str)]\n              (if (-valid? ar) ar ((force b) str)))))\n(defn _try [fake origin]\n  (fn [str] (if (not (-valid? ((force fake) str)))\n              ((force origin) str))))\n(defn _parser [p]\n  (fn [input]\n    (-value ((_combine (fn [v _] v) p (_char #{\\u0000})) (str input \\u0000)))))\n(defn +char [chars] (_char (set chars)))\n(defn +char-not [chars] (_char (comp not (set chars))))\n(defn +map [f parser] (comp (_map f) parser))\n(def +try _try)\n(def +parser _parser)\n\n(def +ignore (partial +map (constantly (quote ignore))))\n(defn iconj [coll value] (if (= value (quote ignore)) coll (conj coll value)))\n(defn +seq [&amp; ps] (reduce (partial _combine iconj) (_empty []) ps))\n(defn +seqf [f &amp; ps] (+map (partial apply f) (apply +seq ps)))\n(defn +seqn [n &amp; ps] (apply +seqf (fn [&amp; vs] (nth vs n)) ps))\n\n(defn conj-list [l v] (apply list (conj (vec l) v)))\n\n(defn +or [p &amp; ps] (reduce (partial _either) p ps))\n(defn +opt [p] (+or p (_empty nil)))\n(defn +star [p] (letfn [(rec [] (+or (+seqf cons p (delay (rec))) (_empty ())))] (rec)))\n(defn +plus [p] (+seqf cons p (+star p)))\n(defn +str [p] (+map (partial apply str) p))\n(defn +string [s] (apply +seqf (constantly s)\n                         (map (comp +char str) (char-array s))))\n\n(def *ws (+ignore (+star (+char \&quot; \\t\\n\\r\&quot;))))\n(def *digit (+char \&quot;0123456789\&quot;))\n(def *number\n  (+map (comp Constant read-string) (+str (+seqf concat\n                                                 (+seqf cons (+opt (+char \&quot;-\&quot;)) (+plus *digit))\n                                                 (+seqf cons (+opt (+char \&quot;.\&quot;)) (+star *digit))))))\n(defn *operator\n  [fakes ops] (+map (comp symbol str)\n                    (apply +or (if (empty? fakes)\n                                 (map +string ops)\n                                 (map #(+try (+string %1) (+string %2)) fakes ops)))))\n(def *all-chars (mapv char (range 32 128)))\n(def *letter (+char (apply str (filter #(Character/isLetter %) *all-chars))))\n(def *variable (+map Variable (+str (+star *letter))))&quot;, :offset 2837, :ns &quot;user&quot;} {:command &quot;(tabulate  +string [\&quot;1\&quot; \&quot;23\&quot; \&quot;4324324.241sadsafa\&quot;])&quot;, :offset 51, :ns &quot;user&quot;} {:command &quot;(tabulate  +string [\&quot;1\&quot; \&quot;23\&quot; \&quot;4324324.241sadsafa\&quot; \&quot;aca\&quot;])&quot;, :offset 57, :ns &quot;user&quot;} {:command &quot;(tabulate  +string [\&quot;1\&quot; \&quot;23\&quot; \&quot;4324324.241sadsafa\&quot; \&quot;aca\&quot; \&quot;+\&quot;])&quot;, :offset 61, :ns &quot;user&quot;} {:command &quot;(+string [\&quot;1\&quot;])&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(+string \&quot;1\&quot;)&quot;, :offset 13, :ns &quot;user&quot;} {:command &quot;((+string \&quot;1\&quot;))&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(+string '+)&quot;, :offset 12, :ns &quot;user&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Application.ClojurePowLogParsingTest">
    <configuration name="ClojurePowLogParsingTest" type="Application" factoryName="Application" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="cljtest.parsing.ClojurePowLogParsingTest" />
      <module name="hw10" />
      <option name="PROGRAM_PARAMETERS" value="hard" />
      <option name="VM_PARAMETERS" value="-ea" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" nameIsGenerated="true">
      <module name="hw10" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Application.ClojurePowLogParsingTest" />
      <item itemvalue="Clojure REPL.Unnamed" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="3197dfe5-7a24-452b-8888-fa7ef8063d5f" name="Default Changelist" comment="" />
      <created>1556909772937</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1556909772937</updated>
      <workItem from="1556909786439" duration="2479000" />
      <workItem from="1557059370607" duration="607000" />
      <workItem from="1557063737895" duration="4429000" />
      <workItem from="1557075248433" duration="24701000" />
      <workItem from="1557137956046" duration="108000" />
      <workItem from="1557658116252" duration="8538000" />
      <workItem from="1557676582215" duration="5981000" />
      <workItem from="1557732662008" duration="1325000" />
      <workItem from="1557734103871" duration="108000" />
      <workItem from="1557742537898" duration="1170000" />
      <workItem from="1557745809415" duration="1205000" />
    </task>
    <servers />
  </component>
  <component name="TimeTrackingManager">
    <option name="totallyTimeSpent" value="50651000" />
  </component>
  <component name="ToolWindowManager">
    <frame x="-8" y="-8" width="1936" height="1056" extended-state="7" />
    <editor active="true" />
    <layout>
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.21641791" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info id="Image Layers" order="2" />
      <window_info id="Designer" order="3" />
      <window_info id="UI Designer" order="4" />
      <window_info id="Capture Tool" order="5" />
      <window_info id="Favorites" order="6" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info anchor="bottom" id="Run" order="2" sideWeight="0.49741602" weight="0.31419286" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.3997833" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.32936078" />
      <window_info anchor="bottom" id="Docker" order="7" show_stripe_button="false" />
      <window_info anchor="bottom" id="Version Control" order="8" weight="0.32936078" />
      <window_info anchor="bottom" id="Database Changes" order="9" />
      <window_info anchor="bottom" id="Terminal" order="10" weight="0.32936078" />
      <window_info anchor="bottom" id="Event Log" order="11" sideWeight="0.502584" side_tool="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Messages" order="12" weight="0.32936078" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="1" weight="0.25" />
      <window_info anchor="right" id="Palette" order="2" />
      <window_info anchor="right" id="Theme Preview" order="3" />
      <window_info anchor="right" id="Ant Build" order="4" sideWeight="0.49919224" weight="0.25" />
      <window_info anchor="right" id="Maven" order="5" weight="0.32995737" />
      <window_info anchor="right" id="Capture Analysis" order="6" />
      <window_info anchor="right" id="Palette&#9;" order="7" />
      <window_info anchor="right" id="Database" order="8" weight="0.32995737" />
      <window_info anchor="right" id="Leiningen" order="9" weight="0.32995737" />
      <window_info anchor="right" id="REPL" order="10" sideWeight="0.50080776" side_tool="true" weight="0.36993605" />
      <window_info anchor="right" id="Coverage" order="11" side_tool="true" weight="0.32995737" />
    </layout>
    <layout-to-restore>
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.015991472" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info id="Image Layers" order="2" />
      <window_info id="Designer" order="3" />
      <window_info id="UI Designer" order="4" />
      <window_info id="Capture Tool" order="5" />
      <window_info id="Favorites" order="6" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info anchor="bottom" id="Run" order="2" sideWeight="0.49741602" visible="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.3997833" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.32936078" />
      <window_info anchor="bottom" id="Docker" order="7" show_stripe_button="false" />
      <window_info anchor="bottom" id="Version Control" order="8" weight="0.32936078" />
      <window_info anchor="bottom" id="Database Changes" order="9" />
      <window_info anchor="bottom" id="Terminal" order="10" weight="0.32936078" />
      <window_info anchor="bottom" id="Event Log" order="11" sideWeight="0.502584" side_tool="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Messages" order="12" weight="0.32936078" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="1" weight="0.25" />
      <window_info anchor="right" id="Palette" order="2" />
      <window_info anchor="right" id="Theme Preview" order="3" />
      <window_info anchor="right" id="Ant Build" order="4" sideWeight="0.49919224" weight="0.25" />
      <window_info anchor="right" id="Maven" order="5" weight="0.32995737" />
      <window_info anchor="right" id="Capture Analysis" order="6" />
      <window_info anchor="right" id="Palette&#9;" order="7" />
      <window_info anchor="right" id="Database" order="8" weight="0.32995737" />
      <window_info anchor="right" id="Leiningen" order="9" weight="0.32995737" />
      <window_info active="true" anchor="right" id="REPL" order="10" sideWeight="0.50080776" side_tool="true" visible="true" weight="0.22867803" />
      <window_info anchor="right" id="Coverage" order="11" side_tool="true" weight="0.32995737" />
    </layout-to-restore>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/clojure/examples.clj">
      <provider selected="true" editor-type-id="text-editor" />
    </entry>
    <entry file="file://$PROJECT_DIR$/java/expression/exceptions/ExceptionsTest.java" />
    <entry file="file://$PROJECT_DIR$/javascript/jstest/BaseJavascriptTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="202">
          <caret line="62" selection-start-line="62" selection-end-line="62" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/object/ClojureObjectExpressionTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="202">
          <caret line="54" selection-start-line="54" selection-end-line="54" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/java/expression/BaseTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="202">
          <caret line="37" selection-start-line="37" selection-end-line="37" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/ClojureScript.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="535">
          <caret line="41" column="27" lean-forward="true" selection-start-line="41" selection-start-column="27" selection-end-line="41" selection-end-column="27" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/parsing/ClojureObjectParsingTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="432">
          <caret line="55" selection-start-line="55" selection-end-line="55" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/ClojureEngine.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="31" selection-start-line="31" selection-end-line="31" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/4_4_macro.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="27" selection-start-line="7" selection-start-column="27" selection-end-line="7" selection-end-column="27" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/4_1_base.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="680">
          <caret line="40" column="106" selection-start-line="40" selection-start-column="9" selection-end-line="40" selection-end-column="106" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/4_3_json.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="255">
          <caret line="15" column="30" lean-forward="true" selection-start-line="15" selection-start-column="30" selection-end-line="15" selection-end-column="30" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/4_2_combinators.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="424">
          <caret line="51" column="14" selection-start-line="51" selection-start-column="10" selection-end-line="51" selection-end-column="14" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/expression.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="408">
          <caret line="24" column="26" lean-forward="true" selection-start-line="24" selection-start-column="26" selection-end-line="24" selection-end-column="26" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/obj.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1785">
          <caret line="105" selection-start-line="105" selection-end-line="105" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/combinators.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="629">
          <caret line="37" column="5" selection-start-line="37" selection-start-column="5" selection-end-line="37" selection-end-column="5" />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>11</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>