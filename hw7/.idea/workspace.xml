<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="39d9b977-6878-491d-8cd5-8eb4defead23" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/linear.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlAllTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlImageTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlLinkTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlMarkTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/artifacts/md2html/Md2HtmlUnderlineTest.jar" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/clojure/examples/1_5_functions-2.clj" beforeDir="false" afterPath="$PROJECT_DIR$/clojure/examples/1_5_functions-2.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsHighLowTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/ExceptionsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/exceptions/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericAsmUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericLsTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/GenericUfbTest.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/generic/Tabulator.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Either.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/Parser.java" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/java/expression/parser/ParserTest.java" beforeDir="false" />
    </list>
    <ignored path="$PROJECT_DIR$/out/" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="CoverageDataManager">
    <SUITE FILE_PATH="coverage/hw7$LinearBroadcastTest.ic" NAME="LinearBroadcastTest Coverage Results" MODIFIED="1555844389203" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" />
  </component>
  <component name="DatabaseView">
    <option name="SHOW_INTERMEDIATE" value="true" />
    <option name="GROUP_DATA_SOURCES" value="true" />
    <option name="GROUP_SCHEMA" value="true" />
    <option name="GROUP_CONTENTS" value="false" />
    <option name="SORT_POSITIONED" value="false" />
    <option name="SHOW_EMPTY_GROUPS" value="false" />
    <option name="AUTO_SCROLL_FROM_SOURCE" value="false" />
    <option name="HIDDEN_KINDS">
      <set />
    </option>
    <expand />
    <select />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/linear.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="421">
              <caret line="129" selection-start-line="129" selection-end-line="129" />
            </state>
          </provider>
        </entry>
      </file>
      <file pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/clojure/cljtest/linear/LinearBinaryTest.java">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="204">
              <caret line="19" selection-start-line="19" selection-end-line="19" />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>letsMultiplyMatrix</find>
      <find>scalar</find>
      <find>redu</find>
      <find>v*s</find>
      <find>comm</find>
      <find>vect</find>
      <find>ms</find>
      <find>sca</find>
      <find>m*v</find>
      <find>transpose</find>
      <find>vs</find>
      <find>matrixI</find>
      <find>tensor</find>
      <find>let</find>
      <find>mat</find>
      <find>b</find>
      <find>cons</find>
      <find>form</find>
      <find>ca</find>
      <find>parti</find>
      <find>broadcast</find>
      <find>canBroadcast</find>
      <find>canB</find>
      <find>make-order</find>
      <find>checkMatrix</find>
      <find>checkMat</find>
      <find>letsCh</find>
      <find>chec</find>
      <find>checkObj</find>
    </findStrings>
  </component>
  <component name="Git.Settings">
    <option name="UPDATE_TYPE" value="MERGE" />
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/clojure/examples/0_1_magic.clj" />
        <option value="$PROJECT_DIR$/clojure/examples/1_5_functions-2.clj" />
        <option value="$PROJECT_DIR$/java/expression/parser/ParserTest.java" />
        <option value="$PROJECT_DIR$/linear.clj" />
      </list>
    </option>
  </component>
  <component name="MavenProjectNavigator">
    <treeState>
      <expand />
      <select />
    </treeState>
  </component>
  <component name="ProjectFrameBounds" extendedState="6">
    <option name="x" value="1093" />
    <option name="width" value="834" />
    <option name="height" value="1047" />
  </component>
  <component name="ProjectView">
    <navigator proportions="" version="1">
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="PackagesPane" />
      <pane id="Scope" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="hw7" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw7" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw7" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw7" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw7" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw7" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw7" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw7" type="462c0819:PsiDirectoryNode" />
              <item name="clojure" type="462c0819:PsiDirectoryNode" />
              <item name="cljtest" type="462c0819:PsiDirectoryNode" />
              <item name="linear" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="hw7" type="b2602c69:ProjectViewProjectNode" />
              <item name="hw7" type="462c0819:PsiDirectoryNode" />
              <item name="java" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="com.android.tools.idea.instantapp.provision.ProvisionBeforeRunTaskProvider.myTimeStamp" value="1555849580493" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/../hw8" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="undefined stuck path" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
    <property name="nodejs_package_manager_path" value="npm" />
  </component>
  <component name="ReplState" timestamp="1556528164457">{:repl-history {:ide [], :local [{:command &quot;(canBroadcast (list 5 1 2 3) (list 4 1 2 3))&quot;, :offset 44, :ns &quot;user&quot;} {:command &quot;(canBroadcast (list 3 2 1) (list 3 1 2))&quot;, :offset 40, :ns &quot;user&quot;} {:command &quot;(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count obj) shape) obj))\n&quot;, :offset 519, :ns &quot;user&quot;} {:command &quot;(broadcast (list 2 1) [1])&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(broadcast (list 10 2 1) [1])&quot;, :offset 29, :ns &quot;user&quot;} {:command &quot;(swap! [1 2] [3 4])&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(max 1 2)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count obj) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    (let [[a b] (make-order first second)]\n      {:pre [(canBroadcast (form a) (form b))]}\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3264, :ns &quot;user&quot;} {:command &quot;(b- 1 2)&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(b* 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(b* 23 1)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(b- [1] [2])&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;(b- [1])&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(b- [3 4])&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(cons 1 2)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(cons (list 1 2 3) (list 4 5 6))&quot;, :offset 32, :ns &quot;user&quot;} {:command &quot;(conj (list 1 2 3) (list 4 5 6))&quot;, :offset 32, :ns &quot;user&quot;} {:command &quot;(cons 5 (list 4 5 6))&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(b+ 1 2 3)&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(form [[1 2]])&quot;, :offset 14, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    (let [[a b] (make-order first second)]\n      {:pre [(canBroadcast (form a) (form b))]}\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3271, :ns &quot;user&quot;} {:command &quot;(+ (broadcast (form [[1 2]]) [1 2]) [[1 2]])&quot;, :offset 44, :ns &quot;user&quot;} {:command &quot;(increase (list 1) [1 2])&quot;, :offset 25, :ns &quot;user&quot;} {:command &quot;(broadcast (form [[1 2]]) [1 2])&quot;, :offset 32, :ns &quot;user&quot;} {:command &quot;(make-order [1 2] [[1 2]])&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    (let [[a b] (make-order first second)]\n      {:pre [(canBroadcast (form a) (form b))]}\n      [a b])))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3248, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [1 2])&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [[1 2]])&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;(b+ [1 2 3] [[1 2]])&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(v- [[1 2]])&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [1 2 3]) (form [[1 2]]))&quot;, :offset 44, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    (let [[a b] (make-order first second)]\n      {:pre [(canBroadcast (form first) (form second))]}\n      [a b])))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3257, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [3 4 5])&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;(b+ [1])&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(b+ [[1 2]] [3 4 5])&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(v- 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(v- [1])&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors), 0))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3328, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) 0 tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3327, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? (nth obj 0))\n    (cons (count obj) (form (nth obj 0)))\n    (list (count obj))))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3325, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    1)\n\n\n  (defn increase [shape obj]\n    (if (empty? shape)\n      obj\n      (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n  (defn broadcast [shape obj]\n    (increase (drop-last (count (form obj)) shape) obj))\n\n\n  (defn make-order [a b]\n    (if (&lt; (count (form a)) (count (form b)))\n      [a b]\n      [b a]))\n\n  (defn binaryTensorOperation [f]\n    (fn [first second]\n      {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n      (let [[a b] (make-order first second)]\n        (f (broadcast (form b) a) b))))\n\n  (defn tensor-operation [f]\n    (fn [&amp; tensors]\n      (reduce (binaryTensorOperation f) tensors)))\n\n\n  (def b+ (tensor-operation +))\n  (def b- (tensor-operation -))\n  (def b* (tensor-operation *))\n\n\n&quot;, :offset 3399, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    1))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3358, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3365, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    {:pre [(or (canBroadcast (form first) (form second)) (canBroadcast (form second) (form first)))]}\n    (let [[a b] (make-order first second)]\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) 0 tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3367, :ns &quot;user&quot;} {:command &quot;(- 0 1)&quot;, :offset 7, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [1 2]) (form [3 4]))&quot;, :offset 40, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [3 4]) (form [1 2]))&quot;, :offset 40, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [[3 4]]) (form [1 2]))&quot;, :offset 42, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [1 2]) (form [[3 4]]))&quot;, :offset 42, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn binaryTensorOperation [f]\n  (fn [first second]\n    (let [[a b] (make-order first second)]\n      {:pre [(not (canBroadcast (form a) (form b)))]}\n      (f (broadcast (form b) a) b))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3317, :ns &quot;user&quot;} {:command &quot;(make-order [1 2] [3 4])&quot;, :offset 24, :ns &quot;user&quot;} {:command &quot;(form [3 4])&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn make-operation [f a b]\n  {:pre [(canBroadcast (form a) (form b))]}\n  (f (broadcast (form b) a) b))\n\n\n(defn binaryTensorOperation [f]\n  (fn [a b]\n    (if (&lt; (count (form a)) (count (form b)))\n      (make-operation f a b)\n      (make-operation f b a))))\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (reduce (binaryTensorOperation f) tensors)))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3387, :ns &quot;user&quot;} {:command &quot;(canBroadcast (form [1 2]) (form [[1 2]]))&quot;, :offset 42, :ns &quot;user&quot;} {:command &quot;(b+ [[1 2]] [1 2 3])&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(+ [[1 2]] [[3 4]])&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn make-operation [f a b]\n  {:pre [(canBroadcast (form a) (form b))]}\n  (f (broadcast (form b) a) b))\n\n\n(defn binaryTensorOperation [f]\n  (fn [a b]\n    (if (&lt; (count (form a)) (count (form b)))\n      (make-operation f a b)\n      (make-operation f b a))))\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [tensor] (count (form (tensor)))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3669, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n(defn make-operation [f a b]\n  {:pre [(canBroadcast (form a) (form b))]}\n  (f (broadcast (form b) a) b))\n\n\n(defn binaryTensorOperation [f]\n  (fn [a b]\n    (if (&lt; (count (form a)) (count (form b)))\n      (make-operation f a b)\n      (make-operation f b a))))\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [tensor] (count (form (tensor)))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3627, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors 1)&quot;, :offset 21, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors [1])&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(greatest-tensors [ 1 [1 2] [[1 2]]])&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [tensor] (count (form (tensor)))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3411, :ns &quot;user&quot;} {:command &quot;(greatest-tensors [[1]] [2])&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects))\n              (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3399, :ns &quot;user&quot;} {:command &quot;(greatest-tensors [[[1]] [2]])&quot;, :offset 30, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3357, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #((broadcast % g)) tensors)))\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3365, :ns &quot;user&quot;} {:command &quot;(b+ 1 2)&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors [1 2] [3 4])&quot;, :offset 31, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors [[1 2] [3 4]])&quot;, :offset 33, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv #(broadcast % g) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3365, :ns &quot;user&quot;} {:command &quot;(b- [3 4] [1 2])&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(b- [1 2] [3 4] [5 6])&quot;, :offset 22, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [3 4] [5 6])&quot;, :offset 22, :ns &quot;user&quot;} {:command &quot;(b+ [[1]] [[2]])&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv (partial broadcast (form g)) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3377, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [3 4])&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(b+ [1 2] [[3 4]])&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;((partial broadcast (form[[3 4]])) [1 2])&quot;, :offset 41, :ns &quot;user&quot;} {:command &quot;(greatest-tensors [[1 2] [[3 4]]])&quot;, :offset 34, :ns &quot;user&quot;} {:command &quot;(mapv (partial broadcast (form[[3 4]])) [[1 2] [[3 4]]])&quot;, :offset 56, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    g)\n\n\n  (defn tensor-operation [f]\n    (fn [&amp; tensors]\n      (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n  (def b+ (tensor-operation +))\n  (def b- (tensor-operation -))\n  (def b* (tensor-operation *))\n\n\n&quot;, :offset 3346, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors [[1 2] [[3 4]]])&quot;, :offset 35, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv (partial broadcast g) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3370, :ns &quot;user&quot;} {:command &quot;(b+ 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(b- 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)) (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv (partial broadcast g) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n\n\n&quot;, :offset 3398, :ns &quot;user&quot;} {:command &quot;(b+ 10 [1.0 2.3121])&quot;, :offset 20, :ns &quot;user&quot;} {:command &quot;(b+ 10 [1 2])&quot;, :offset 13, :ns &quot;user&quot;} {:command &quot;(defn checkVector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn checkMatrix [matrix]\n  (and (vector? matrix)\n       (every? checkVector matrix)\n       (apply = (mapv count matrix))))\n\n(defn makeEmpty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv makeEmpty obj) obj)))\n\n(defn letsCheck [obj emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv letsCheck obj emp)))))\n\n(defn checkObject [obj]\n  (letsCheck obj (makeEmpty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)) (checkObject (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n\n(defn vectorOperation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? checkVector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vectorOperation +))\n(def v- (vectorOperation -))\n(def v* (vectorOperation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vectorMultiply [a b]\n  {:pre [(and (checkVector a) (checkVector b)\n              (checkObject (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vectorMultiply vs))\n(defn v*s [v &amp; s]\n  {:pre [(and (checkVector v) (checkVector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(checkMatrix a)]}\n  (apply mapv vector a))\n\n(defn matrixOperation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? checkMatrix matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrixOperation +))\n(def m- (matrixOperation -))\n(def m* (matrixOperation *))\n(def m* (matrixOperation *))\n\n(defn m*s [m &amp; s]\n  {:pre [(and (checkMatrix m) (checkVector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (checkMatrix m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrixMultiply [a b]\n  {:pre [(and (checkMatrix a) (checkMatrix b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrixMultiply ms))\n\n(defn countSuf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (countSuf (rest a) (rest b)))\n      0)))\n\n(defn canBroadcast [a b]\n  (== (countSuf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj)))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn make-order [a b]\n  (if (&lt; (count (form a)) (count (form b)))\n    [a b]\n    [b a]))\n\n\n(defn greatest-tensors [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensors tensors))]\n    {:pre [every? #((canBroadcast (form %) g)) tensors]}\n    (mapv (partial broadcast g) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))&quot;, :offset 3395, :ns &quot;user&quot;} {:command &quot;(b+ 10 [1 2])\n&quot;, :offset 14, :ns &quot;user&quot;} {:command &quot;(b+ [[1 2]] [3 4])&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;(broadcast-tensors [10 [1 2]])&quot;, :offset 30, :ns &quot;user&quot;} {:command &quot;(greatest-tensors [10 [1 2]])&quot;, :offset 29, :ns &quot;user&quot;} {:command &quot;(form [1 2])&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;((partial broadcast (form [1 2])) 10)&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(broadcast (list 2) 10)&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(form 10)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(defn check-vector [vector]\n  (and (vector? vector)\n       (every? number? vector)))\n\n(defn matrix? [matrix]\n  (and (vector? matrix)\n       (every? check-vector matrix)\n       (apply = (mapv count matrix))))\n\n(defn make-empty [obj]\n  (if (number? obj)\n    [] (if (vector? obj)\n         (mapv make-empty obj) obj)))\n\n(defn check [emp]\n  (or (empty? emp) (and (vector? emp)\n                        (apply = emp)\n                        (every? true? (mapv check emp)))))\n\n(defn object? [obj]\n  (check (make-empty obj)))\n\n(defn operation [f &amp; objects]\n  {:pre [(and (not (empty? objects)) (object? (vec objects)))]}\n  (if (number? (first objects))\n    (apply f objects)\n    (apply mapv (partial operation f) objects)))\n\n\n(defn vector-operation [f]\n  (fn [&amp; vectors]\n    {:pre [(every? check-vector vectors)]}\n    (apply (partial operation f) vectors)))\n\n(def v+ (vector-operation +))\n(def v- (vector-operation -))\n(def v* (vector-operation *))\n\n(defn scalar [a b]\n  (apply + (v* a b)))\n\n\n(defn vector-multiply [a b]\n  {:pre [(and (check-vector a) (check-vector b)\n              (object? (vector a b))\n              (== (count a) (count b) 3))]}\n  [(- (* (nth a 1) (nth b 2)) (* (nth a 2) (nth b 1)))\n   (- (* (nth a 2) (nth b 0)) (* (nth a 0) (nth b 2)))\n   (- (* (nth a 0) (nth b 1)) (* (nth a 1) (nth b 0)))])\n\n(defn vect [&amp; vs]\n  (reduce vector-multiply vs))\n\n\n(defn v*s [v &amp; s]\n  {:pre [(and (check-vector v) (check-vector (vec s)))]}\n  (mapv (partial * (apply * s)) v))\n\n\n(defn transpose [a]\n  {:pre [(matrix? a)]}\n  (apply mapv vector a))\n\n(defn matrix-operation [f]\n  (fn [&amp; matrixs]\n    {:pre [(every? matrix? matrixs)]}\n    (apply (partial operation f) matrixs)))\n\n(def m+ (matrix-operation +))\n(def m- (matrix-operation -))\n(def m* (matrix-operation *))\n\n\n(defn m*s [m &amp; s]\n  {:pre [(and (matrix? m) (check-vector (vec s)))]}\n  (mapv #(apply v*s % s) m))\n\n(defn m*v [m v]\n  {:pre [(and (matrix? m) (not (empty? v)))]}\n  (mapv (partial scalar v) m))\n\n(defn matrix-multiply [a b]\n  {:pre [(and (matrix? a) (matrix? b)\n              (== (count (a 0)) (count b)))]}\n  (transpose (mapv (partial m*v a) (transpose b))))\n\n(defn m*m [&amp; ms]\n  {:pre [(not (empty? ms))]}\n  (reduce matrix-multiply ms))\n\n(defn count-suf [a b]\n  (if (empty? a)\n    0\n    (if (== (first a) (first b))\n      (inc (count-suf (rest a) (rest b)))\n      0)))\n\n(defn broadcast? [a b]\n  (== (count-suf (reverse a) (reverse b)) (count a)))\n\n(defn form [obj]\n  (if (vector? obj)\n    (if (vector? (nth obj 0))\n      (cons (count obj) (form (nth obj 0)))\n      (list (count obj) 1))\n    (list 1)))\n\n\n(defn increase [shape obj]\n  (if (empty? shape)\n    obj\n    (vec (repeat (first shape) (increase (rest shape) obj)))))\n\n(defn broadcast [shape obj]\n  (increase (drop-last (count (form obj)) shape) obj))\n\n\n(defn greatest-tensor [tensors]\n  (apply max-key (fn [t] (count (form t))) tensors))\n\n(defn broadcast-tensors [tensors]\n  (let [g (form (greatest-tensor tensors))]\n    {:pre [every? #((broadcast? (form %) g)) tensors]}\n    (mapv (partial broadcast g) tensors)))\n\n\n(defn tensor-operation [f]\n  (fn [&amp; tensors]\n    (apply (partial operation f) (broadcast-tensors tensors))))\n\n\n(def b+ (tensor-operation +))\n(def b- (tensor-operation -))\n(def b* (tensor-operation *))\n&quot;, :offset 3236, :ns &quot;user&quot;} {:command &quot;(b+ [[\&quot;a\&quot;]] [[\&quot;c\&quot;]])&quot;, :offset 20, :ns &quot;user&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Unnamed">
    <configuration name="LinearBroadcastTest" type="Application" factoryName="Application" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="cljtest.linear.LinearBroadcastTest" />
      <module name="hw7" />
      <option name="VM_PARAMETERS" value="-ea" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" nameIsGenerated="true">
      <module name="hw7" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Application.LinearBroadcastTest" />
      <item itemvalue="Clojure REPL.Unnamed" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="39d9b977-6878-491d-8cd5-8eb4defead23" name="Default Changelist" comment="" />
      <created>1554470432251</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1554470432251</updated>
      <workItem from="1554470436841" duration="406000" />
      <workItem from="1554471131808" duration="3645000" />
      <workItem from="1554482952153" duration="3859000" />
      <workItem from="1554498260211" duration="51000" />
      <workItem from="1554724945024" duration="8648000" />
      <workItem from="1554739459301" duration="111000" />
      <workItem from="1554739601308" duration="320000" />
      <workItem from="1554743101684" duration="16083000" />
      <workItem from="1554799458616" duration="4977000" />
      <workItem from="1554819288701" duration="188000" />
      <workItem from="1554819507772" duration="94000" />
      <workItem from="1554820316715" duration="3022000" />
      <workItem from="1554824942846" duration="651000" />
      <workItem from="1555834062127" duration="14435000" />
      <workItem from="1555857617423" duration="2310000" />
      <workItem from="1556477369044" duration="66000" />
      <workItem from="1556527430156" duration="734000" />
      <workItem from="1556533505740" duration="14000" />
    </task>
    <servers />
  </component>
  <component name="TimeTrackingManager">
    <option name="totallyTimeSpent" value="59614000" />
  </component>
  <component name="TodoView">
    <todo-panel id="selected-file">
      <is-autoscroll-to-source value="true" />
    </todo-panel>
    <todo-panel id="all">
      <are-packages-shown value="true" />
      <is-autoscroll-to-source value="true" />
    </todo-panel>
  </component>
  <component name="ToolWindowManager">
    <frame x="-8" y="-8" width="1936" height="1056" extended-state="6" />
    <layout>
      <window_info content_ui="combo" id="Project" order="0" visible="true" weight="0.11567164" />
      <window_info id="Structure" order="1" side_tool="true" weight="0.25" />
      <window_info id="Image Layers" order="2" />
      <window_info id="Designer" order="3" />
      <window_info id="UI Designer" order="4" />
      <window_info id="Capture Tool" order="5" />
      <window_info id="Favorites" order="6" side_tool="true" />
      <window_info anchor="bottom" id="Message" order="0" />
      <window_info anchor="bottom" id="Find" order="1" />
      <window_info anchor="bottom" id="Run" order="2" sideWeight="0.49626866" weight="0.31419286" />
      <window_info anchor="bottom" id="Debug" order="3" weight="0.3997833" />
      <window_info anchor="bottom" id="Cvs" order="4" weight="0.25" />
      <window_info anchor="bottom" id="Inspection" order="5" weight="0.4" />
      <window_info anchor="bottom" id="TODO" order="6" weight="0.32936078" />
      <window_info anchor="bottom" id="Docker" order="7" show_stripe_button="false" />
      <window_info anchor="bottom" id="Version Control" order="8" weight="0.32936078" />
      <window_info anchor="bottom" id="Database Changes" order="9" />
      <window_info anchor="bottom" id="Terminal" order="10" weight="0.32936078" />
      <window_info anchor="bottom" id="Event Log" order="11" sideWeight="0.50373137" side_tool="true" visible="true" weight="0.31419286" />
      <window_info anchor="bottom" id="Messages" order="12" weight="0.32936078" />
      <window_info anchor="right" id="Commander" internal_type="SLIDING" order="0" type="SLIDING" weight="0.4" />
      <window_info anchor="right" content_ui="combo" id="Hierarchy" order="1" weight="0.25" />
      <window_info anchor="right" id="Palette" order="2" />
      <window_info anchor="right" id="Theme Preview" order="3" />
      <window_info anchor="right" id="Ant Build" order="4" sideWeight="0.49919224" weight="0.25" />
      <window_info anchor="right" id="Maven" order="5" weight="0.32995737" />
      <window_info anchor="right" id="Capture Analysis" order="6" />
      <window_info anchor="right" id="Palette&#9;" order="7" />
      <window_info anchor="right" id="Database" order="8" weight="0.32995737" />
      <window_info anchor="right" id="Leiningen" order="9" weight="0.32995737" />
      <window_info active="true" anchor="right" id="REPL" order="10" sideWeight="0.50080776" side_tool="true" visible="true" weight="0.5074627" />
      <window_info anchor="right" id="Coverage" order="11" side_tool="true" weight="0.32995737" />
    </layout>
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="antWorkspaceConfiguration">
    <option name="IS_AUTOSCROLL_TO_SOURCE" value="false" />
    <option name="FILTER_TARGETS" value="false" />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/clojure/examples/0_1_magic.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="187">
          <caret line="11" column="20" selection-start-line="11" selection-start-column="20" selection-end-line="11" selection-end-column="20" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/1_1_intro.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="799">
          <caret line="47" column="26" selection-start-line="47" selection-start-column="26" selection-end-line="47" selection-end-column="26" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/1_3_lists.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="391">
          <caret line="23" column="19" selection-start-line="23" selection-start-column="19" selection-end-line="23" selection-end-column="19" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/1_4_vectors.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="221">
          <caret line="13" column="21" selection-start-line="13" selection-start-column="21" selection-end-line="13" selection-end-column="21" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/1_5_functions-2.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="340">
          <caret line="20" column="24" selection-start-line="20" selection-start-column="24" selection-end-line="20" selection-end-column="24" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/examples/1_2_functions.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="254">
          <caret line="64" column="21" selection-start-line="64" selection-start-column="21" selection-end-line="64" selection-end-column="21" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/java/expression/parser/ParserTest.java" />
    <entry file="file://$PROJECT_DIR$/java/expression/exceptions/ExceptionsTest.java" />
    <entry file="jar://C:/Program Files/Java/jdk-11.0.2/lib/src.zip!/java.base/java/net/SocketInputStream.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1054">
          <caret line="92" column="23" selection-start-line="92" selection-start-column="23" selection-end-line="92" selection-end-column="23" />
        </state>
      </provider>
    </entry>
    <entry file="jar://$PROJECT_DIR$/clojure/lib/clojure-1.10.0.jar!/clojure/lang/Util.class">
      <provider selected="true" editor-type-id="text-editor" />
    </entry>
    <entry file="file://$PROJECT_DIR$/java/base/Asserts.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="203">
          <caret line="19" selection-start-line="19" selection-end-line="19" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/ClojureScript.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="23" selection-start-line="23" selection-end-line="23" />
          <folding>
            <element signature="e#336#337#0" expanded="true" />
            <element signature="e#407#408#0" expanded="true" />
          </folding>
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/linear.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="421">
          <caret line="129" selection-start-line="129" selection-end-line="129" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/clojure/cljtest/linear/LinearBinaryTest.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="204">
          <caret line="19" selection-start-line="19" selection-end-line="19" />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>11</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>